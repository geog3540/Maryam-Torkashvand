<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">

  <title>migrationstructures</title>

  <!-- Bootstrap CSS -->

  <!--<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">-->

  <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

  <!-- Custom styles for this template -->
  <link href="css/3-col-portfolio.css" rel="stylesheet">


  <!--<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.4/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>-->
  <script src="https://d3js.org/d3.v6.min.js"></script>

  <style>
  /* Remove the navbar's default margin-bottom and rounded borders */
  .custom-navbar {
    background-color: #14365D;
  }

  /* Add a gray background color and some padding to the footer */
  footer {
    background-color: #f2f2f2;
    padding: 25px;
  }

  body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
  }

  .container {
    padding: 20px;
  }


  .map-container {
    position: relative;
    display: inline-block;
    margin: 20px auto;
    width: calc(50% - 20px); /* 50% width for 2 columns, minus 20px for margin */
  }

  .compare-btn {
    position: absolute;
    bottom: 10px;
    right: 10px;
    z-index: 10;
  }

  .map-description {
    position: absolute;
    margin: 0;
    padding: 0;
    width: 400px;
    border: 1px solid #ccc;
    background-color: #f2f2f2;
    font-size: 14px;
    text-align: justify;
  }

  </style>
</head>

<body>
  <nav class="navbar navbar-expand-lg navbar-dark custom-navbar fixed-top">
    <div class="container">
      <a class="navbar-brand" href="#">Maryam Torkashvand Portfolio</a>
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarResponsive">
        <ul class="navbar-nav ml-auto">
          <li class="nav-item active">
            <a class="nav-link" href="#">Home
              <span class="sr-only">(current)</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="shortbio.html">About</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="files/Torkashvand_CV_March-2023.pdf">My C.V.</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="mailto:maryam-torkashvand@uiowa.edu">Contact</a>
          </li>
        </ul>
      </div>
    </div>
  </nav>

  <div class="container">
    <h1>Migration Structures in the United States (1910-1920)</h1>
  </div>
  <div class="container text-center">
    <p>Mapping migration regions using two network community detection algorithms. The visualization method employed ensures consistency by maintaining the same color for each region across both maps, allowing for easier comparison and interpretation</p>
  </div>

  <div class="row">
    <div id="mapGrid" class="row">
      <!-- Maps will be appended here -->
    </div>
  </div>
</div>

<script>

async function getCommunitiesFromGeoJSON(filePaths) {
  const communities = [];

  for (const filePath of filePaths) {
    const response = await fetch(filePath);
    const geoJsonData = await response.json();
    const community = geoJsonData.features.map(feature => feature.properties.leidenpart);
    communities.push(community);
  }

  return communities;
}

function pairCountingSimilarity(communities1, communities2) {
  if (communities1.length !== communities2.length) {
    throw new Error("Input arrays must have the same length");
  }

  //initialize the variables
  let matches = 0;
  let totalPairs = 0;

  //define the unique pairs of nodes (0,1),(0,2), ... (n-1,n)
  for (let i = 0; i < communities1.length; i++) {
    for (let j = i + 1; j < communities1.length; j++) {
      totalPairs++;

      //chech whether those pairs that are in a same community in network 1 also are the same community in network 2
      //if true, add 1 to the match variable
      if (communities1[i] === communities1[j] && communities2[i] === communities2[j]) {
        matches++;
      }
    }
  }
  return matches / totalPairs;
}


//////////////////////////////////////////////////////////////////////////////////
  function createTable(container, data) {
    const table = container.append('table')
      .attr('class', 'table table-bordered table-hover');

    const thead = table.append('thead');
    const tbody = table.append('tbody');

    // Add table headers
    thead.append('tr')
      .selectAll('th')
      .data(Object.keys(data[0]))
      .enter()
      .append('th')
      .text(d => d);

    // Add table rows
    const rows = tbody.selectAll('tr')
      .data(data)
      .enter()
      .append('tr');

    // Add table cells
    rows.selectAll('td')
      .data(d => Object.values(d))
      .enter()
      .append('td')
      .text(d => d);
  }


  function drawMap(mapId, geoJsonData, partitionAttribute, colorScale) {
    const width = 700;
    const height = 610;
    const projection = d3.geoAlbersUsa().scale(900).translate([width / 2, height / 2]);
    const path = d3.geoPath().projection(projection);

    const svg = d3.select("#" + mapId)
    .append("svg")
    .attr("width", width)
    .attr("height", height);

    //const features = svg.selectAll("g.feature")
    //.data(geoJsonData.features)
    //.join("g")
    //.attr("class", "feature");

    //features.append("path")
    //.attr("d", path)
    //.attr("fill", d => colorScale(d.properties[partitionAttribute]))
    //.attr("stroke", "white")
    //.attr("stroke-width", 1);

    //features.append("text")
    //.attr("x", d => path.centroid(d)[0])
    //.attr("y", d => path.centroid(d)[1])
    //.attr("text-anchor", "middle")
    //.attr("font-size", "10px")
    //.text(d => `ID: ${d.id}, Partition: ${d.properties[partitionAttribute]}`);
  //}


    svg.selectAll("path")
    .data(geoJsonData.features)
    .join("path")
    .attr("d", path)
    .attr("fill", d => colorScale(d.properties[partitionAttribute]))
    .attr("stroke", "white")
    .attr("stroke-width", 1)
    .on("mouseover", function (event, d) {
      d3.select(this)
      .append("title")
      .text(`ID: ${d.id},Partition: ${d.properties[partitionAttribute]}`);
    })
    .on("mouseout", function () {
      d3.select(this)
      .selectAll("title")
      .remove();;
      });
    }

  const colorScale = d3.scaleOrdinal(d3.schemeCategory10);

  // List of GeoJSON file paths
  const mapFiles = [
    "data/louvain.geojson", "data/leiden.geojson","data/leiden1900_1910.geojson", "data/Louvain1900_1910.geojson"
  ];

  let similarityDictionary = {};

  const descriptionFiles = [
    "data/description1.txt",
    // Add more description file names here
  ];

  const mapGrid = document.getElementById("mapGrid");

  //d3.text("data/Leiden_partition_summary_1910_1920.txt").then(function (text) {
  //const mapDescriptions = text.split("\n");

  function loadDescription(filename, mapContainer) {
    d3.text(filename).then(function (text) {
      const paragraphs = text.split("\n\n");
      paragraphs.forEach(function (paragraph) {
        if (paragraph.trim() !== "") {
          mapContainer.append("p")
          .attr("class", "map-description")
          .text(paragraph);
        }
      });
    });
  }

  getCommunitiesFromGeoJSON(mapFiles).then(communities => {
    console.log("Communities array:", communities);

    const similarityDict = {};


    for (let i = 0; i < communities.length; i++) {
      for (let j = i + 1; j < communities.length; j++) {
        const key = `${i}-${j}`;
        const similarityScore = pairCountingSimilarity(communities[i], communities[j]);
        similarityDict[key] = similarityScore;
      }
    }

    similarityDictionary = similarityDict;
    console.log("Similarity dictionary:", similarityDictionary);

  });


  for (let i = 0; i < mapFiles.length; i++) {
    const mapId = "map" + i;
    const mapContainer = d3.select("#mapGrid")
    .append("div")
    .attr("class", "col-md-4 map-container");

    mapContainer.append("div")
    .attr("id", mapId)
    .attr("class", "map");

    // Create a dropdown menu
    const dropdown = mapContainer.append("select")
    .attr("class", "form-control compare-dropdown")

    // Add options to the dropdown menu
    for (let j = 0; j < mapFiles.length; j++) {
      if (j !== i) {
        dropdown.append("option")
        .attr("value", j)
        .text("Compare with Map " + (j + 1));
      }
    }

    // Add a change event listener to the dropdown menu
    dropdown.on("change", function () {
      const selectedMapIndex = parseInt(this.value);
      // Add your compare functionality here
      const key = `${i}-${selectedMapIndex}`;
      const similarityValue = similarityDictionary[key]
      console.log(`Comparing map ${i + 1} with map ${selectedMapIndex + 1}`);
      alert(`Similarity between Map ${i + 1} and Map ${selectedMapIndex + 1}: ${similarityValue}`);
    });

    d3.json(mapFiles[i]).then(geoJsonData => {
      const partitionAttribute = i == 0 ? "leidenpart" : "louvainpar";
      drawMap(mapId, geoJsonData, partitionAttribute, colorScale);



      // Add data for the table
      //const tableData = geoJsonData.features.map(feature => ({
        //id: feature.id,
        //partition: feature.properties[partitionAttribute],
      //}));
        // Create the table under the map
        //createTable(mapContainer, tableData);
      //mapContainer.append("p")
      //.text(mapDescriptions[i]);
      const descriptionFilename = descriptionFiles[i];
      loadDescription(descriptionFilename, mapContainer);
      });
    }

</script>
</body>
</html>
